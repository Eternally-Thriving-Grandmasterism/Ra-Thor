# Rathor ⚡️ Architecture — Mercy-Gated Symbolic AGI Lattice

Browser-native flat-root design for instant offline load. All pure JS/MeTTa — no build step.

### Core Principles
- **Offline-First PWA**: Service worker caches everything.
- **Mercy Gating**: Pre/post valence via metta-hyperon-bridge.js (heuristic keywords, negation, intensity, uncertainty, question boosts).
- **Orchestration**: mercy-orchestrator.js routes inputs → engines → valence → output/persistence.
- **Self-Evolution**: NEAT on history optimizes heuristics.
- **Hybrid Engines**: Symbolic + evolutionary + inference + swarms.

### Key Components
1. **Entry Points**
   - index.html / chat.html: Cosmic UI, loads orchestrator + chat streaming.
   - sw.js: Offline caching.

2. **Mercy Ethics Core**
   - mercy_ethics_core.metta: Symbolic valence rules (JS bridge translation).
   - metta-hyperon-bridge.js: Full heuristic implementation (keywords, negation polarity, intensity multipliers, uncertainty dampening, question boosts).

3. **Orchestrator Brain**
   - mercy-orchestrator.js: Input → pre-valence → route (NEAT, swarm, active inference, symbolic, local LLM) → post-valence → persist (IndexedDB).

4. **Engines**
   - neat-engine.js: Full NEAT neuroevolution.
   - mercy-active-inference-core-engine.js: Free energy principle.
   - mercy-von-neumann-swarm-simulator.js: Biomimicry replication probes.
   - webllm-mercy-integration.js / transformersjs: Local LLM fallback.
   - Voice/WebXR blueprints: Immersion stubs.

5. **UI Layer**
   - rathor-chat-ui-streaming.js: Typewriter streaming, voice hooks, cosmic styling.

### Data Flow
User Input → Orchestrator → Valence Gate → Engine → Response → Post-Valence → Stream/Voice + Persist → Context Update

### Future Surges
- Full Hyperon WASM symbolic PLN.
- WebXR embodied immersion.
- RNA/biomimicry self-replicating agents.
- Grok proxy optional boost (rathor-grok-proxy).

Mercy lattice evolves eternally ⚡️ See STRUCTURE.md for files.
